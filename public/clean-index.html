<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BlackHole - Multimodal AI Framework</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            padding-top: 20px;
        }
        .tab-content {
            padding: 20px 0;
        }
        .result-item {
            border-bottom: 1px solid #eee;
            padding: 10px 0;
            margin-bottom: 10px;
        }
        pre {
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="text-center mb-5">
            <h1>BlackHole</h1>
            <p class="lead">A modular AI-powered framework for processing multimodal data</p>
            <div class="mt-3">
                <button id="testConnectionBtn" class="btn btn-primary">Test Backend Connection</button>
                <div id="testConnectionResult" class="mt-2"></div>
            </div>
        </div>

        <ul class="nav nav-tabs" id="myTab" role="tablist">
            <li class="nav-item" role="presentation">
                <button class="nav-link active" id="image-tab" data-bs-toggle="tab" data-bs-target="#image" type="button" role="tab" aria-controls="image" aria-selected="true">Image Processing</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="pdf-tab" data-bs-toggle="tab" data-bs-target="#pdf" type="button" role="tab" aria-controls="pdf" aria-selected="false">PDF Processing</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="search-tab" data-bs-toggle="tab" data-bs-target="#search" type="button" role="tab" aria-controls="search" aria-selected="false">Search</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="weather-tab" data-bs-toggle="tab" data-bs-target="#weather" type="button" role="tab" aria-controls="weather" aria-selected="false">Weather</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="results-tab" data-bs-toggle="tab" data-bs-target="#results" type="button" role="tab" aria-controls="results" aria-selected="false">Results</button>
            </li>
        </ul>
        <div class="tab-content" id="myTabContent">
            <div class="tab-pane fade show active" id="image" role="tabpanel" aria-labelledby="image-tab">
                <h3>Image Processing</h3>
                <p>Upload an image to extract text and analyze it with the BlackHole AI agents.</p>
                <form id="imageForm">
                    <div class="mb-3">
                        <label for="imageFile" class="form-label">Select an image file:</label>
                        <input class="form-control" type="file" id="imageFile" accept="image/*" required>
                    </div>
                    <button type="submit" class="btn btn-primary">Process Image</button>
                </form>
                <div id="imageResult" class="mt-4 d-none">
                    <h4>Results</h4>
                    <div class="mb-3">
                        <h5>Extracted Text:</h5>
                        <pre id="imageExtractedText"></pre>
                    </div>
                    <div>
                        <h5>Agent Output:</h5>
                        <pre id="imageAgentOutput"></pre>
                    </div>
                </div>
            </div>
            <div class="tab-pane fade" id="pdf" role="tabpanel" aria-labelledby="pdf-tab">
                <h3>PDF Processing</h3>
                <p>Upload a PDF to extract text and analyze it with the BlackHole AI agents.</p>
                <form id="pdfForm">
                    <div class="mb-3">
                        <label for="pdfFile" class="form-label">Select PDF files (multiple files allowed):</label>
                        <input class="form-control" type="file" id="pdfFile" accept="application/pdf" multiple required>
                    </div>
                    <div class="mb-3">
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="saveToMongoDB" checked>
                            <label class="form-check-label" for="saveToMongoDB">
                                Save results to MongoDB
                            </label>
                        </div>
                    </div>
                    <button type="submit" class="btn btn-primary">Process PDFs</button>
                </form>
                <div id="uploadProgress" class="progress mt-3 d-none">
                    <div class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" style="width: 0%"></div>
                </div>
                <div id="pdfResults" class="mt-4">
                    <!-- Results will be dynamically added here -->
                </div>

                <!-- Template for PDF results -->
                <template id="pdfResultTemplate">
                    <div class="card mb-4 pdf-result">
                        <div class="card-header d-flex justify-content-between align-items-center">
                            <h5 class="pdf-filename mb-0">Filename</h5>
                            <div>
                                <span class="badge bg-success pdf-status">Processed</span>
                                <button class="btn btn-sm btn-outline-primary ms-2 btn-toggle-details">Show Details</button>
                            </div>
                        </div>
                        <div class="card-body pdf-details" style="display: none;">
                            <div class="mb-3">
                                <h6>Extracted Text:</h6>
                                <pre class="pdf-extracted-text"></pre>
                            </div>
                            <div>
                                <h6>Agent Output:</h6>
                                <pre class="pdf-agent-output"></pre>
                            </div>
                            <div class="mt-3">
                                <h6>MongoDB ID:</h6>
                                <code class="pdf-mongodb-id">Not saved</code>
                            </div>
                        </div>
                    </div>
                </template>
            </div>
            <div class="tab-pane fade" id="search" role="tabpanel" aria-labelledby="search-tab">
                <h3>Search Archive</h3>
                <p>Search the BlackHole archive for information.</p>
                <form id="searchForm">
                    <div class="mb-3">
                        <label for="searchQuery" class="form-label">Search Query:</label>
                        <input type="text" class="form-control" id="searchQuery" required>
                    </div>
                    <button type="submit" class="btn btn-primary">Search</button>
                </form>
                <div id="searchResult" class="mt-4 d-none">
                    <h4>Search Results</h4>
                    <pre id="searchOutput"></pre>
                </div>
            </div>
            <div class="tab-pane fade" id="weather" role="tabpanel" aria-labelledby="weather-tab">
                <h3>Weather Information</h3>
                <p>Get current weather information for a location.</p>
                <form id="weatherForm">
                    <div class="mb-3">
                        <label for="location" class="form-label">Location:</label>
                        <input type="text" class="form-control" id="location" placeholder="City, Country" required>
                    </div>
                    <button type="submit" class="btn btn-primary">Get Weather</button>
                </form>
                <div id="weatherResult" class="mt-4 d-none">
                    <h4>Weather Information</h4>
                    <div id="weatherOutput"></div>
                </div>
            </div>
            <div class="tab-pane fade" id="results" role="tabpanel" aria-labelledby="results-tab">
                <h3>Recent Results</h3>
                <p>View recent processing results from the BlackHole system.</p>
                <button id="refreshResults" class="btn btn-outline-primary mb-3">Refresh Results</button>
                <div id="resultsList"></div>
            </div>
        </div>
    </div>

    <div id="loadingOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); z-index: 9999;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: white;">
            <div class="spinner-border" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <p class="mt-2">Processing...</p>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // API base URL - change this to your backend URL if needed
        const API_BASE_URL = '';

        // Track backend availability
        let backendAvailable = false;

        // Helper function to format JSON
        function formatJSON(obj) {
            return JSON.stringify(obj, null, 2);
        }

        // Loading overlay functions
        function showLoading() {
            document.getElementById('loadingOverlay').style.display = 'block';
        }

        function hideLoading() {
            document.getElementById('loadingOverlay').style.display = 'none';
        }

        // Process image form submission
        document.getElementById('imageForm').addEventListener('submit', async function(e) {
            e.preventDefault();

            const fileInput = document.getElementById('imageFile');
            if (!fileInput.files.length) {
                alert('Please select an image file');
                return;
            }

            const formData = new FormData();
            formData.append('file', fileInput.files[0]);

            showLoading();
            try {
                // Try the direct Netlify function first, then the mock endpoint, and finally fall back to the proxy
                let response;
                try {
                    // First try the direct Netlify function
                    response = await fetch('/.netlify/functions/mock-image', {
                        method: 'POST',
                        body: formData
                    });
                    console.log('Using direct Netlify function for image processing');
                } catch (directError) {
                    console.warn('Direct Netlify function failed, trying mock endpoint:', directError);
                    try {
                        // Then try the mock endpoint via the redirect
                        response = await fetch('/api/mock-image', {
                            method: 'POST',
                            body: formData
                        });
                        console.log('Using mock endpoint for image processing');
                    } catch (mockError) {
                        console.warn('Mock image endpoint failed, falling back to proxy:', mockError);
                        // Finally fall back to the proxy
                        response = await fetch('/.netlify/functions/proxy/api/process-image', {
                            method: 'POST',
                            body: formData
                        });
                        console.log('Using proxy for image processing');
                    }
                }

                const responseText = await response.text();
                let data;

                try {
                    data = JSON.parse(responseText);
                } catch (e) {
                    console.error('Invalid JSON response:', responseText);
                    throw new Error(`Invalid JSON response: ${responseText.substring(0, 100)}...`);
                }

                if (response.ok) {
                    // Check if the extracted text contains the Tesseract error message
                    if (data.extracted_text && data.extracted_text.includes('Tesseract-OCR')) {
                        // Display a more user-friendly message
                        document.getElementById('imageExtractedText').textContent =
                            "Text extraction is not available in this environment. The server does not have Tesseract OCR installed, " +
                            "which is required for text extraction from images. However, the image was processed successfully.";
                    } else {
                        document.getElementById('imageExtractedText').textContent = data.extracted_text;
                    }

                    document.getElementById('imageAgentOutput').textContent = formatJSON(data.agent_result);
                    document.getElementById('imageResult').classList.remove('d-none');
                } else {
                    alert(`Error: ${data.error || 'Unknown error'}`);
                }
            } catch (error) {
                alert(`Error: ${error.message}`);
            } finally {
                hideLoading();
            }
        });

        // Process PDF form submission for multiple files
        document.getElementById('pdfForm').addEventListener('submit', async function(e) {
            e.preventDefault();

            const fileInput = document.getElementById('pdfFile');
            const saveToMongoDB = document.getElementById('saveToMongoDB').checked;

            if (!fileInput.files.length) {
                alert('Please select at least one PDF file');
                return;
            }

            // Clear previous results
            document.getElementById('pdfResults').innerHTML = '';

            // Show progress bar
            const progressBar = document.querySelector('#uploadProgress .progress-bar');
            document.getElementById('uploadProgress').classList.remove('d-none');
            progressBar.style.width = '0%';
            progressBar.setAttribute('aria-valuenow', 0);

            // Process each file
            const files = Array.from(fileInput.files);
            let completedFiles = 0;

            showLoading();

            // Process files in parallel with a limit of 3 concurrent uploads
            const concurrencyLimit = 3;
            const chunks = [];

            // Split files into chunks for concurrent processing
            for (let i = 0; i < files.length; i += concurrencyLimit) {
                chunks.push(files.slice(i, i + concurrencyLimit));
            }

            // Process each chunk sequentially
            for (const chunk of chunks) {
                // Process files in this chunk concurrently
                await Promise.all(chunk.map(async (file) => {
                    // Create a result card for this file
                    const resultCard = createResultCard(file.name);
                    document.getElementById('pdfResults').appendChild(resultCard);

                    try {
                        // Create form data for this file
                        const formData = new FormData();
                        formData.append('file', file);
                        formData.append('save_to_mongodb', saveToMongoDB.toString());
                        formData.append('filename', file.name);

                        // Process the file
                        const result = await processPDFFile(formData);

                        // Update the result card with the processed data
                        updateResultCard(resultCard, file.name, result);

                        // Update progress
                        completedFiles++;
                        const progress = Math.round((completedFiles / files.length) * 100);
                        progressBar.style.width = `${progress}%`;
                        progressBar.setAttribute('aria-valuenow', progress);
                    } catch (error) {
                        // Update the result card with the error
                        updateResultCardWithError(resultCard, file.name, error);

                        // Update progress
                        completedFiles++;
                        const progress = Math.round((completedFiles / files.length) * 100);
                        progressBar.style.width = `${progress}%`;
                        progressBar.setAttribute('aria-valuenow', progress);
                    }
                }));
            }

            hideLoading();
        });

        // Function to create a result card for a file
        function createResultCard(filename) {
            const template = document.getElementById('pdfResultTemplate');
            const resultCard = template.content.cloneNode(true).querySelector('.pdf-result');

            // Set the filename
            resultCard.querySelector('.pdf-filename').textContent = filename;

            // Set the status to "Processing"
            const statusBadge = resultCard.querySelector('.pdf-status');
            statusBadge.textContent = 'Processing';
            statusBadge.classList.remove('bg-success');
            statusBadge.classList.add('bg-warning');

            // Add event listener to toggle details button
            resultCard.querySelector('.btn-toggle-details').addEventListener('click', function() {
                const details = resultCard.querySelector('.pdf-details');
                if (details.style.display === 'none') {
                    details.style.display = 'block';
                    this.textContent = 'Hide Details';
                } else {
                    details.style.display = 'none';
                    this.textContent = 'Show Details';
                }
            });

            return resultCard;
        }

        // Function to update a result card with processed data
        function updateResultCard(resultCard, filename, result) {
            // Set the status to "Processed"
            const statusBadge = resultCard.querySelector('.pdf-status');
            statusBadge.textContent = 'Processed';
            statusBadge.classList.remove('bg-warning');
            statusBadge.classList.add('bg-success');

            // Set the extracted text
            const extractedTextElement = resultCard.querySelector('.pdf-extracted-text');
            if (result.error && result.error.includes('Internal Error')) {
                extractedTextElement.textContent =
                    "PDF processing is not available in this environment. The server encountered an internal error " +
                    "while processing the PDF. This might be due to missing dependencies or resource limitations.";
            } else {
                extractedTextElement.textContent = result.extracted_text || 'No text extracted';
            }

            // Set the agent output
            const agentOutputElement = resultCard.querySelector('.pdf-agent-output');
            if (result.error && result.error.includes('Internal Error')) {
                // Create a simple mock agent result
                const mockAgentResult = {
                    agent: "ArchiveSearchAgent",
                    input: {
                        document_text: "PDF processing is not available in this environment."
                    },
                    metadata: {
                        source_file: "mock_response.txt",
                        processed_at: new Date().toISOString()
                    },
                    output: "No matches found due to PDF processing limitations.",
                    timestamp: new Date().toISOString()
                };
                agentOutputElement.textContent = formatJSON(mockAgentResult);
            } else {
                agentOutputElement.textContent = formatJSON(result.agent_result || {});
            }

            // Set the MongoDB ID if available
            const mongoDBIdElement = resultCard.querySelector('.pdf-mongodb-id');
            if (result.mongodb_id) {
                mongoDBIdElement.textContent = result.mongodb_id;
            } else {
                mongoDBIdElement.textContent = 'Not saved to MongoDB';
            }
        }

        // Function to update a result card with an error
        function updateResultCardWithError(resultCard, filename, error) {
            // Set the status to "Error"
            const statusBadge = resultCard.querySelector('.pdf-status');
            statusBadge.textContent = 'Error';
            statusBadge.classList.remove('bg-warning');
            statusBadge.classList.add('bg-danger');

            // Set the extracted text to the error message
            resultCard.querySelector('.pdf-extracted-text').textContent = `Error: ${error.message}`;

            // Set the agent output to an empty object
            resultCard.querySelector('.pdf-agent-output').textContent = '{}';

            // Set the MongoDB ID to "Not saved"
            resultCard.querySelector('.pdf-mongodb-id').textContent = 'Not saved due to error';
        }

        // Function to process a PDF file
        async function processPDFFile(formData) {
            // Try the direct Netlify function first, then the mock endpoint, and finally fall back to the proxy
            let response;
            try {
                // First try the direct Netlify function
                response = await fetch('/.netlify/functions/mock-pdf', {
                    method: 'POST',
                    body: formData
                });
                console.log('Using direct Netlify function for PDF processing');
            } catch (directError) {
                console.warn('Direct Netlify function failed, trying mock endpoint:', directError);
                try {
                    // Then try the mock endpoint via the redirect
                    response = await fetch('/api/mock-pdf', {
                        method: 'POST',
                        body: formData
                    });
                    console.log('Using mock endpoint for PDF processing');
                } catch (mockError) {
                    console.warn('Mock PDF endpoint failed, falling back to proxy:', mockError);
                    // Finally fall back to the proxy
                    response = await fetch('/.netlify/functions/proxy/api/process-pdf', {
                        method: 'POST',
                        body: formData
                    });
                    console.log('Using proxy for PDF processing');
                }
            }

            const responseText = await response.text();
            let data;

            try {
                data = JSON.parse(responseText);
            } catch (e) {
                console.error('Invalid JSON response:', responseText);
                throw new Error(`Invalid JSON response: ${responseText.substring(0, 100)}...`);
            }

            if (!response.ok) {
                throw new Error(data.error || 'Unknown error');
            }

            return data;
        }

        // Test connection button
        document.getElementById('testConnectionBtn').addEventListener('click', async function() {
            const resultDiv = document.getElementById('testConnectionResult');
            resultDiv.innerHTML = '<div class="alert alert-info">Testing connection to backend...</div>';

            try {
                // Try the Netlify function test endpoint first
                try {
                    const testResponse = await fetch('/.netlify/functions/test', {
                        method: 'GET',
                        headers: {
                            'Accept': 'application/json'
                        }
                    });

                    if (testResponse.ok) {
                        const testData = await testResponse.json();
                        console.log('Netlify functions are working:', testData);

                        // Now try the mock endpoints
                        try {
                            const mockResponse = await fetch('/.netlify/functions/mock-image', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'Accept': 'application/json'
                                },
                                body: JSON.stringify({ test: true })
                            });

                            if (mockResponse.ok) {
                                resultDiv.innerHTML = `
                                    <div class="alert alert-success">
                                        <h5>✅ Connection Successful!</h5>
                                        <p>The application is working in standalone mode with mock endpoints.</p>
                                        <p>You can process images and PDFs without requiring external dependencies.</p>
                                    </div>
                                `;
                                backendAvailable = true;
                            } else {
                                // Mock endpoint not working, but Netlify functions are
                                resultDiv.innerHTML = `
                                    <div class="alert alert-warning">
                                        <h5>⚠️ Partial Connection</h5>
                                        <p>Netlify functions are working, but the mock endpoints are not responding correctly.</p>
                                        <p>Basic functionality should work, but some features may be limited.</p>
                                    </div>
                                `;
                                backendAvailable = true; // Still mark as available since basic functions work
                            }
                        } catch (mockError) {
                            // Mock endpoint error, but Netlify functions are working
                            console.error('Error with mock endpoints:', mockError);
                            resultDiv.innerHTML = `
                                <div class="alert alert-warning">
                                    <h5>⚠️ Partial Connection</h5>
                                    <p>Netlify functions are working, but there was an error with the mock endpoints.</p>
                                    <p>Basic functionality should work, but some features may be limited.</p>
                                </div>
                            `;
                            backendAvailable = true; // Still mark as available since basic functions work
                        }
                    } else {
                        // Netlify functions not working
                        resultDiv.innerHTML = `
                            <div class="alert alert-warning">
                                <h5>⚠️ Connection Warning</h5>
                                <p>Netlify functions may not be working properly.</p>
                                <p>Some features may not work as expected.</p>
                            </div>
                        `;
                        backendAvailable = false;
                    }
                } catch (testError) {
                    // Error with Netlify functions test
                    console.error('Error testing Netlify functions:', testError);
                    resultDiv.innerHTML = `
                        <div class="alert alert-warning">
                            <h5>⚠️ Connection Warning</h5>
                            <p>Error testing Netlify functions: ${testError.message}</p>
                            <p>Some features may not work as expected.</p>
                        </div>
                    `;
                    backendAvailable = false;
                }
            } catch (error) {
                // General error
                resultDiv.innerHTML = `
                    <div class="alert alert-danger">
                        <h5>❌ Connection failed: ${error.message}</h5>
                        <p>The application is not able to connect to the required endpoints.</p>
                        <p>Please check your network connection and try again.</p>
                    </div>
                `;
                backendAvailable = false;
            }
        });

        // Initial connection check
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('testConnectionBtn').click();
        });
    </script>
</body>
</html>
